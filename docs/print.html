<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CrossCheck</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/theme.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="philosophy.html"><strong aria-hidden="true">2.</strong> Philosophy</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">CrossCheck</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>CrossCheck is a highly composable and ergonomic validation and schema library.</p>
<p>It was extracted from Conde Nast CMS system, which supports more than 100 brands with similar, but not always identical validation and schema requirements. This environment gives rise to significant extensibility requirements, so CrossCheck's primitives are designed with extensibility in mind.</p>
<p>All CrossCheck primitives produce well-typed, well-defined JSON objects. This is intended to allow applications to store schemas in a database or build UIs to generate them.</p>
<a class="header" href="#architecture" id="architecture"><h1>Architecture</h1></a>
<div class=diagram>
  <img alt="CrossCheck Architecture" src="./diagrams/architecture.svg">
</div>
<p>CrossCheck is divided up into three libraries:</p>
<ol>
<li><code>@cross-check/core</code>, which defines the core data structures of CrossCheck validations and the core validation function. The core data structures are designed with composition in mind.</li>
<li><code>@cross-check/dsl</code>, which provides additional conveniences on top of the core data structures. This library provides convenient composition functionality, building on top of the capabilities enabled by the core data structure.</li>
<li><code>@cross-check/schema</code> is a schema library built on top of CrossCheck validations. It provides additional functionality such as the ability to serialize and deserialize data, the ability to have runtime modes such as &quot;draft mode&quot; or &quot;readonly mode&quot;. It also has a built-in mechanism for registering data types and serializing them into your database, and built-in formatters that can produce TypeScript and GraphQL output for your schemas, and can be extended to generate an adapter to any other data modelling library you use.</li>
</ol>
<p>Because of the way that <code>@cross-check/dsl</code> is layered on top of <code>@cross-check/core</code>, you can build validation descriptors (the core data type of CrossCheck) manually, and still use those descriptors in <code>@cross-check/schema</code>.</p>
<p>This enables the creation of UIs for building and composing validators and schemas that can be stored in a database without requiring every new validation rule to be checked in to source control. This is a big win for extensible systems like the one at Conde Nast.</p>
<a class="header" href="#validators" id="validators"><h3>Validators</h3></a>
<p>At the lowest level, CrossCheck allows you to define validation rules that can be applied to any value.</p>
<p>For example, let's say we want to define a validator that validates that a numeric input is greater than some value.</p>
<p>CrossCheck's validation primitive is called a &quot;validation descriptor&quot;, and this is a descriptor for <code>gt(10)</code>:</p>
<pre><code class="language-ts">const gt = {
  name: &quot;gt&quot;,
  options: 10
  validator: (options) =&gt; (value) =&gt; (value &gt; options) ? valid() : invalid(&quot;gt&quot;, 10),
};
</code></pre>
<p>Let's look more closely at the validator property, expanded out:</p>
<pre><code class="language-ts">function validator(options: number) {
  return (value: number) =&gt; {
    if (value &gt; options) {
      return valid();
    } else {
      return invalid(&quot;gt&quot;, 10);
    }
  }
}
</code></pre>
<p>A validator is a function that takes options, and returns a new function that takes a value. That new function is responsible for validating the value in accordance with the options, and return <code>valid()</code> if the value matches or <code>invalid(name, details)</code> if the value does not match.</p>
<p>Validators don't throw exceptions. Instead, they return an array of validation errors, which can be separately presented to the user as needed, and crucially, can be internationalized as needed.</p>
<p>All together:</p>
<pre><code class="language-ts">import { validate, valid, invalid } from &quot;@cross-check/core&quot;;

// Define the validation descriptor
const gt = {
  name: &quot;gt&quot;,
  options: 10
  validator: (floor) =&gt; (value) =&gt; (value &gt; floor) ? valid() : invalid(&quot;gt&quot;, 10),
};

// Call validate() with the value and validation descriptor, which returns an async result.
// The result will either be `[]` if there are no errors, or an array containing one or more
// errors.
await validate(5, gt);
// [{ message: { name: &quot;gt&quot;, details: 10 }, path: [] }]

await validate(15, gt);
// []
</code></pre>
<p>When validating a single value, the <code>path</code> property is always empty. When we discuss schemas later, we'll see that the <code>path</code> property allows us to compose arbitrarily nested data structures conveniently.</p>
<p>If you wanted to export <code>gt</code> as a validator in your own project using the core primitive, you would probably create a module:</p>
<pre><code class="language-ts">import { valid, invalid } from &quot;@cross-check/core&quot;;

export function gt(floor) {
  return value =&gt; {
    if (value &gt; floor) {
      return valid();
    } else {
      return invalid(&quot;gt&quot;, floor);
    }
  }
}
</code></pre>
<p>You could now import <code>gt</code> from another module and call <code>validate(value, gt)</code>, as we saw above. The core primitive is self-contained and easy to understand.
The conveniences in <code>@cross-check/dsl</code> simply make it a little nicer to build and compose validators.</p>
<p><a href="./validators.html">Learn more about @cross-check/core</a></p>
<a class="header" href="#composing-validators" id="composing-validators"><h3>Composing Validators</h3></a>
<p>There are a few main ways that you may want to compose validators:</p>
<ol>
<li>&quot;all are valid&quot;: Run both validators. Concatenate the errors and return them.</li>
<li>Example: &quot;check that this number is greater than 5 and less than 10&quot;</li>
<li>&quot;pipeline&quot;: Run the first validator. If it fails, return its errors. If it succeeds, run the second validator and return its errors.</li>
<li>Example: &quot;check that this value is a string, and then check that this value is a valid URL&quot;</li>
<li>&quot;any are valid&quot;: Run both validators. If any of them succeeds, return an empty list. Otherwise, return an error containing both lists of errors.</li>
</ol>
<p>The <code>@cross-check/dsl</code> package makes it easy to compose validators in this way.</p>
<a class="header" href="#all-composition" id="all-composition"><h4>&quot;All&quot; Composition</h4></a>
<p>Let's assume the existence of <code>gt</code> and <code>lt</code> validators. We would like to create a <code>range</code> validator that takes two parameters, a start and end position.</p>
<pre><code class="language-ts">import { gt, lt } from &quot;my-library&quot;;
import { compose } from &quot;cross-check/dsl&quot;;

export function range(start, end) {
  // TODO: Move [BUILD] into @cross-check/core to allow mixing
  // and matching the builder with the core primitive
  return compose(gt(start)).andAlso(lt(end))
}
</code></pre>
<p>You can keep chaining <code>.andAlso()</code>s too. Let's say we want to make a validator that also checks to make sure that the number is an integer.</p>
<pre><code class="language-ts">import { gt, lt, int } from &quot;my-library&quot;;
import { compose } from &quot;cross-check/dsl&quot;;

export function wholeNumberInRange(start, end) {
  // TODO: Move [BUILD] into @cross-check/core to allow mixing
  // and matching the builder with the core primitive
  return compose(int()).andAlso(gt(start)).andAlso(lt(end))
}
</code></pre>
<a class="header" href="#pipeline-composition" id="pipeline-composition"><h4>&quot;Pipeline&quot; Composition</h4></a>
<p>Sometimes, you only want to run a subsequent validator if an earlier one succeeded. For example, let's say we want to validate that a value is a string, and only if it is a string, confirm that it's a valid URL.</p>
<p>The <code>.andThen()</code> composition is designed for this situation:</p>
<pre><code class="language-ts">import { string, url } from &quot;my-library&quot;;
import { compose } from &quot;cross-check/dsl&quot;;

export function validURL() {
  return compose(string()).andThen(url())
}
</code></pre>
<p>[Learn more about composition using @cross-check/dsl][dsl-composition]</p>
<p>[Learn more about low-level composition in @cross-check/core][core-composition]</p>
<a class="header" href="#extensibility-first" id="extensibility-first"><h2>Extensibility First</h2></a>
<p>CrossCheck schemas can be <strong>extended</strong>. You can create a single base type that can be customized for different uses or by different brands in a larger organization.</p>
<p>CrossCheck schemas can be <strong>evolved</strong> without big-bang data migrations. Instead, data created under v1 of a schema can be viewed through the lens of v2 of the same schema. Schema evolution is baked into CrossCheck from the ground up.</p>
<p>CrossCheck schemas are <strong>resilient</strong> to old, invalid data or improperly imported data. Define fix-up rules for invalid data and CrossCheck can clean up broken data on the fly. No need to run migrations against all your old data or force every API client to harden itself against the possibility of broken data.</p>
<a class="header" href="#important-schema-features" id="important-schema-features"><h2>Important Schema Features</h2></a>
<ul>
<li><strong>Draft Mode</strong>: Defining a schema automatically generates a &quot;draft schema&quot;, to make it easier to save in-progress work that doesn't yet satisfy the strict schema requirements.</li>
<li><strong>Rich Types</strong>: Any concept that you can write a validation function for can be used as a schema type: URL, single word string, Date formatted as 8601, etc.</li>
<li><strong>Composable Types</strong>: Put types inside of lists or dictionaries, and get errors when the constituent parts are invalid.</li>
<li><strong>Custom Types</strong>: Turn any CrossCheck validator into a CrossCheck schema type.</li>
<li><strong>TypeScript Support</strong>: Turn any CrossCheck schema into a TypeScript interface.</li>
<li><strong>Pretty Printing</strong>: Use the CrossCheck formatter API to turn your schema into the format expected by another library. Need to generate MobX classes? Want to generate GraphQL schemas? No problem!</li>
</ul>
<a class="header" href="#important-validator-features" id="important-validator-features"><h2>Important Validator Features</h2></a>
<ul>
<li><strong>Value-based</strong>: Validate values, not just objects (&quot;validate that this value is a titlecase string&quot;)</li>
<li><strong>Async</strong>: Validators can be async (&quot;validate that this is a unique email address&quot;)</li>
<li><strong>No exceptions</strong>: Validators produce an error list and don't throw exceptions</li>
<li><strong>Easy to Localize</strong>: Validation errors are structured data, not an English string (so errors can be easily localized)</li>
<li><strong>Composable</strong>: Validators can be pipelined: &quot;this type should not be null, and then it should be a string, and then it should be a valid email&quot;. Sub-validators can be reused, making it easier to build up larger validations and ensuring that errors have a consistent structure.</li>
<li><strong>Framework Friendly</strong>: Validation rules are agnostic to how properties are looked up inside of object (so they naturally support Immutable.js or other APIs that look up properties using <code>.get</code> or similar)</li>
<li><strong>Pretty Printing</strong>: CrossCheck can pretty-print validators for documentation and debugging</li>
<li>A single validator can produce multiple errors</li>
</ul>
<a class="header" href="#philosophy" id="philosophy"><h1>Philosophy</h1></a>
<p>CrossCheck's primary goal is to create a highly composable and ergonomic validation system.</p>
<a class="header" href="#high-level-architecture" id="high-level-architecture"><h2>High Level Architecture</h2></a>
<p>The data structures and core functions are found in <code>@cross-check/core</code> to create a small, well-defined composition boundary. The primary data structure in <code>@cross-check/core</code> is <code>ValidationDescriptor</code>.</p>
<p>Higher level tools for building up validations are found in <code>@cross-check/dsl</code>. Validators written against the interfaces in <code>@cross-check/core</code> will compose reliably with validators created using the higher level abstractions (including the object oriented abstractions).</p>
<p>Finally, while <code>@cross-check/core</code> and <code>@cross-check/dsl</code> validate values, <code>@cross-check/schema</code> validates entire records against a schema, with facilities optimized for that use case. The <code>@cross-check/schema</code> library also creates <code>ValidationDescriptor</code>, and the errors produced when validating a schema are the same <code>ValidationError</code>s in <code>@cross-check/core</code>.</p>
<a class="header" href="#typescript-hardened" id="typescript-hardened"><h2>TypeScript Hardened</h2></a>
<p>CrossCheck defines a handful of core, composable interfaces that are defined rigorously in TypeScript. Convenience abstractions are layered on top, sharing a stable core primitive.</p>
<pre><code class="language-ts">// A validation descriptor is an instance of a validator including a descriptive
// name and its options
interface ValidationDescriptor&lt;T, Options&gt; {
  name: string;
  validator(options: Options): Validator&lt;T&gt;;
  options: Options;
}

// A validator is a function that takes a value and produces (asynchronously)
// a list of validation errors.
type Validator&lt;T&gt; = (value: T) =&gt; Promise&lt;ValidationError[]&gt;;

// A validation error is a path to error and an error message, which contains
// the name of the error and additional details provided by the validator.
interface ValidationError {
  path: string[];
  message: {
    name: string;
    details: unknown;
  }
}
</code></pre>
<a class="header" href="#composition-at-the-core" id="composition-at-the-core"><h2>Composition at the Core</h2></a>
<p>The CrossCheck core data structure is called <code>ValidationDescriptor</code>, and its goal is to provide a highly composable but relatively unopinionated primitive for building composed validators.</p>
<a class="header" href="#validate-values" id="validate-values"><h3>Validate Values</h3></a>
<p>At the core, CrossCheck validates individual values, not a bunch of fields on an object.</p>
<p>This makes it possible to validate that a single string matches a particular format, or that a number is greater than some lower bound.</p>
<p>To validate an object, CrossCheck validates the object as a &quot;value&quot; and uses composition to validate its constituent parts. Several design decisions of the core data structure make such composition possible:</p>
<ul>
<li>A single validator can return <strong>any number of errors</strong>. This makes it possible for a single validator to run sub-validators on sub-parts of the object in question.</li>
<li>Validation errors <strong>include a path</strong> member, which provides the path to the place where the error occurred. Validations that validate sub-properties, like the object or array validator, prepend the path that they plucked off. This also allows arbitrary nesting: each validator that plucks off a sub-part of an object prepends the path it added.</li>
</ul>
<p>These design decisions also make array validations relatively consistent: an array validator runs the same sub-validator on every element of the array, and produces an error whose path is the index into the array.</p>
<p>This makes validating an array of objects containing members that are <strong>themselves arrays of objects</strong> a standard composition in CrossCheck.</p>
<p><strong>There is no distinction between a &quot;single value&quot; and an object or array.</strong> A value is a value is a value. Composition takes care of the rest.</p>
<a class="header" href="#no-exceptions-and-no-mutation" id="no-exceptions-and-no-mutation"><h3>No Exceptions and No Mutation</h3></a>
<p>CrossCheck validations are functional, not effectful.</p>
<p>CrossCheck never mutates the underlying objects in order to validate them or report errors. It also does not throw exceptions in order to report validation errors like many schema validation libraries.</p>
<p>The CrossCheck validation process <strong>reads data</strong> from objects and produces an array of error messages.</p>
<a class="header" href="#localization-agnostic-but-formatting-friendly" id="localization-agnostic-but-formatting-friendly"><h3>Localization Agnostic, But Formatting Friendly</h3></a>
<p>Validation libraries usually make formatting a responsibility of individual validators.</p>
<p>This forces a hard choice between bad options:</p>
<ul>
<li>provide no localization solution at all</li>
<li>hardcode support for a specific localization library</li>
<li>force people to write new implementations of the validations for each localization solution they want to use</li>
</ul>
<p>The CrossCheck validation function produces a data structure containing enough information to create localized, formatted error messages, rather than making formatting an additional responsibility of validators.</p>
<pre><code class="language-json">[{
  &quot;path&quot;: [&quot;lat&quot;],
  &quot;message&quot;: {
    &quot;key&quot;: &quot;gt&quot;,
    &quot;args&quot;: { &quot;expected&quot;: 0, &quot;actual&quot;: -50 }
  }
}]
</code></pre>
<p>Validators themselves are responsible for producing these error message data structures, but not for formatting. This allows validators to remain compact and still relatively easy to write, while allowing for robust and high-quality localizations.</p>
<p>In practice, higher-level libraries written on top of these primitives should expose integration with localization libraries, but validators themselves can remain agnostic to those questions.</p>
<a class="header" href="#ui-friendly" id="ui-friendly"><h3>UI Friendly</h3></a>
<p>A good validation library provides rich error information to a human end-user, typically presented via an interactive UI.</p>
<p>This means that attempting to validate an entire object must:</p>
<ul>
<li>produce a list of validation errors</li>
<li>identify precisely where the validation errors occured in a way that is consumable by an interactive UI</li>
<li>provide the error messages in a format that can be localized into various languages and contexts</li>
</ul>
<p>This stands in contrast with traditional schema libraries, which usually assume that they are validating data against programmer error, and accept or reject entire entities.</p>
<p>CrossCheck schemas are built on top of the CrossCheck validation primitive, which means that when a document fails to validate, you get a list of rich errors back that can be presented to an end user.</p>
<p>In our original design exploration for CrossCheck, we wrote:</p>
<blockquote>
<p>The accurate placement of errors in a form (a UI concern!) is a key requirement of a good validation library.</p>
</blockquote>
<p>This is still a good guiding principle for CrossCheck. <strong>A good validation library cannot avoid considering UI concerns in its core design.</strong></p>
<a class="header" href="#framework-agnostic-but-framework-friendly" id="framework-agnostic-but-framework-friendly"><h3>Framework Agnostic, But Framework Friendly</h3></a>
<p>CrossCheck was extracted from the requirements of a working validation system that powered Condé Nast's CMS, which is written in Ember.</p>
<p>One of the main goals of the extraction was to allow people to define validation rules for their forms without needing to understand Ember or its object model.</p>
<p>However, we wanted to make it possible to write validators that could be shared between vanilla environments and frameworks.</p>
<p>This mostly amounts to two concerns.</p>
<p><em>First</em>, applications should be able to expose well-defined &quot;services&quot; to validations. If a validator depends on such a service, and somebody wants to use the validator in a different environment (such as React Native), they will have a clear, pure-JavaScript definition of what they will need to implement.</p>
<p>In practice, this means that integrations can expose things like a configuration service or feature flagging infrastructure.</p>
<p><em>Second</em>, it should be possible to write a validator that looks up properties on an object, agnostic to how those properties should be looked up. For example, looking up a property in an Immutable.js Map requires the user to use .get(). Knockout turns computed getters into functions (to look up firstName on a Person object, you say person.firstName()).</p>
<p>In the case of both of these issues (services and getters), the philosophy of CrossCheck is to expose hooks on an &quot;Environment&quot; that framework integrators can use to abstract these distinctions. Validators receive this environment as a parameter, and if validator definitions work through the Environment (e.g. looking up properties by using environment.get rather than direct indexing), they will be reusable in more environments and with more kinds of data structures.</p>
<p>Because it can be difficult to remember to work through the environment all the time, the @cross-check/dsl library provides a number of abstractions that do the work for you. For example, the object() validator provided by @cross-check/dsl automatically looks up sub-properties by using environment.get.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
